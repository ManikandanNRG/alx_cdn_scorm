<style>
.local-alx-cdn-player-container {
    width: 100%;
    min-width: 1024px; /* Force desktop layout */
    margin: 0 auto;
}
.scorm-frame-wrapper {
    width: 100%;
    min-height: 600px;
    position: relative;
}
.scorm-frame-wrapper iframe {
    width: 100% !important;
    min-width: 1024px !important;
    height: 800px !important; /* Fixed height to fit within page */
    border: none;
}
</style>

<div class="local-alx-cdn-player-container">
    <div class="scorm-frame-wrapper">
        <iframe id="scorm_object" 
                src="{{iframe_src}}" 
                frameborder="0" 
                allowfullscreen="allowfullscreen" 
                webkitallowfullscreen="webkitallowfullscreen" 
                mozallowfullscreen="mozallowfullscreen">
        </iframe>
    </div>
    <div id="scorm-debug-log" style="display:none; border:1px solid #ccc; max-height: 200px; overflow:auto;"></div>
</div>

<script>
// Inline Bridge Controller (no AMD compilation needed)
(function() {
    var state = {
        scormid: {{{bridge_scormid}}},
        scoid: {{{bridge_scoid}}},
        cmid: {{{bridge_cmid}}},
        attempt: {{{bridge_attempt}}},
        debug: {{{bridge_debug}}},
        wwwroot: '{{{bridge_wwwroot}}}',
        sesskey: '{{{bridge_sesskey}}}',
        data: {{{scorm_data_json}}}  // Pre-loaded tracking data from PHP
    };
    
    var log = function(msg) {
        if (state.debug && console && console.log) {
            console.log("[Bridge] " + msg);
        }
    };
    
    // Log loaded data count
    log("SCORM data initialized with " + Object.keys(state.data).length + " elements");
    
    var getValue = function(element) {
        return state.data[element] || "";
    };
    
    var setValue = function(element, value) {
        state.data[element] = value;
        return "true";
    };
    
    var saveRetryCount = 0;
    var maxRetries = 3;
    var retryDelay = 2000; // 2 seconds
    
    var commit = function(isRetry) {
        if (!isRetry) {
            saveRetryCount = 0;
        }
        
        log("Committing data to server..." + (isRetry ? " (Retry " + saveRetryCount + "/" + maxRetries + ")" : ""));
        log("Current state.data: " + JSON.stringify(state.data));
        
        var tracks = [];
        for (var key in state.data) {
            // Only save CMI elements (skip Moodle metadata fields)
            if (key.indexOf('cmi.') === 0 || key.indexOf('cmi_') === 0) {
                tracks.push({ element: key, value: state.data[key] });
            } else {
                log("Skipping non-CMI element: " + key);
            }
        }
        
        log("Tracks to save: " + tracks.length + " items");
        if (tracks.length === 0) {
            log("WARNING: No tracks to save!");
            return "true";
        }
        
        // Use Moodle's AJAX
        require(['core/ajax'], function(Ajax) {
            log("Calling save_tracks web service...");
            Ajax.call([{
                methodname: 'local_alx_cdn_scorm_save_tracks',
                args: {
                    scormid: state.scormid,
                    scoid: state.scoid,
                    attempt: state.attempt,
                    tracks: tracks
                }
            }])[0].done(function(response) {
                log("Save success: " + JSON.stringify(response));
                saveRetryCount = 0; // Reset retry count on success
            }).fail(function(ex) {
                log("Save FAILED: " + JSON.stringify(ex));
                console.error("Save error:", ex);
                
                // Retry logic for network failures
                if (saveRetryCount < maxRetries) {
                    saveRetryCount++;
                    log("Retrying save in " + (retryDelay/1000) + " seconds...");
                    setTimeout(function() {
                        commit(true);
                    }, retryDelay);
                } else {
                    log("ERROR: Save failed after " + maxRetries + " attempts. Data may be lost!");
                    console.error("CRITICAL: Unable to save SCORM data after multiple attempts");
                }
            });
        });
        
        return "true";
    };
    
    var loadData = function() {
        log("Loading user data for resume...");
        
        require(['core/ajax'], function(Ajax) {
            Ajax.call([{
                methodname: 'local_alx_cdn_scorm_get_user_tracks',
                args: {
                    scormid: state.scormid,
                    scoid: state.scoid,
                    attempt: state.attempt
                }
            }])[0].done(function(response) {
                log("Data loaded: " + (response.tracks ? response.tracks.length : 0) + " items");
                if (response.tracks) {
                    response.tracks.forEach(function(track) {
                        state.data[track.element] = track.value;
                    });
                }
            }).fail(function(ex) {
                log("Data load failed: " + JSON.stringify(ex));
            });
        });
    };
    
    // Create SCORM API object
    var ScormAPI = {
        LMSInitialize: function(param) {
            log("LMSInitialize called");
            return "true";
        },
        
        LMSFinish: function(param) {
            log("LMSFinish called");
            commit();
            return "true";
        },
        
        LMSGetValue: function(element) {
            log("LMSGetValue: " + element);
            return getValue(element);
        },
        
        LMSSetValue: function(element, value) {
            log("LMSSetValue: " + element + " = " + value);
            return setValue(element, value);
        },
        
        LMSCommit: function(param) {
            log("LMSCommit called");
            return commit();
        },
        
        LMSGetLastError: function() { return "0"; },
        LMSGetErrorString: function(errorCode) { return "No error"; },
        LMSGetDiagnostic: function(errorCode) { return "No diagnostic"; }
    };
    
    // SCORM 2004 API
    var ScormAPI2004 = {
        Initialize: ScormAPI.LMSInitialize,
        Terminate: ScormAPI.LMSFinish,
        GetValue: ScormAPI.LMSGetValue,
        SetValue: ScormAPI.LMSSetValue,
        Commit: ScormAPI.LMSCommit,
        GetLastError: ScormAPI.LMSGetLastError,
        GetErrorString: ScormAPI.LMSGetErrorString,
        GetDiagnostic: ScormAPI.LMSGetDiagnostic
    };
    
    // Handle postMessage from iframe  
    var handleMessage = function(event) {
        var iframe = document.getElementById('scorm_object');
        if (!iframe || !event.source) return;
        
        try {
            var msg = JSON.parse(event.data);
            if (msg.source !== 'scorm_content') return;
            
            log("Received message: " + msg.type);
            
            var response = {
                source: 'scorm_bridge',
                id: msg.id,
                result: 'true'
            };
            
            switch (msg.type) {
                case 'LMSInitialize':
                    response.result = ScormAPI.LMSInitialize(msg.param);
                    break;
                case 'LMSGetValue':
                    response.result = ScormAPI.LMSGetValue(msg.element);
                    break;
                case 'LMSSetValue':
                    response.result = ScormAPI.LMSSetValue(msg.element, msg.value);
                    break;
                case 'LMSCommit':
                    response.result = ScormAPI.LMSCommit(msg.param);
                    break;
                case 'LMSFinish':
                    response.result = ScormAPI.LMSFinish(msg.param);
                    break;
            }
            
            event.source.postMessage(JSON.stringify(response), "*");
        } catch (e) {
            // Not our message
        }
    };
    
    // Expose APIs
    window.API = ScormAPI;
    window.API_1484_11 = ScormAPI2004;
    
    // Listen for messages
    window.addEventListener("message", handleMessage, false);
    
    log("Bridge Controller Initialized (Inline) for SCORM " + state.scormid);
    
    // Auto-commit on page unload to save data even if SCORM doesn't call Finish
    window.addEventListener("beforeunload", function() {
        log("Page unloading - auto-committing data...");
        commit();
    });
    
    // Periodic auto-save every 30 seconds
    setInterval(function() {
        if (Object.keys(state.data).length > 0) {
            log("Periodic auto-save triggered");
            commit();
        }
    }, 30000);
    
    // Load existing data
    if (typeof require !== 'undefined') {
        loadData();
    }
})();
</script>
